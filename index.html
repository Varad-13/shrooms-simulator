<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Hallucination</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Space Mono', monospace;
            user-select: none;
            touch-action: none; /* Prevents scrolling on mobile while interacting */
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 1.5rem;
            padding: 2rem;
            box-sizing: border-box;
            color: white;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
        }

        .interactive-controls {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(8px);
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        /* Glitch Effect for Title */
        .glitch {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            animation: shift 3s infinite;
        }

        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
        }

        .glitch::before {
            left: 2px;
            text-shadow: -1px 0 #ff00c1;
            clip-path: inset(44% 0 61% 0);
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }

        .glitch::after {
            left: -2px;
            text-shadow: -1px 0 #00fff9;
            clip-path: inset(50% 0 30% 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes shift {
            0%, 100% { transform: skewX(0deg); }
            5% { transform: skewX(2deg); }
            10% { transform: skewX(-2deg); }
            15% { transform: skewX(0deg); }
        }

        @keyframes glitch-anim-1 {
            0% { clip-path: inset(20% 0 80% 0); }
            20% { clip-path: inset(60% 0 10% 0); }
            40% { clip-path: inset(40% 0 50% 0); }
            60% { clip-path: inset(80% 0 5% 0); }
            80% { clip-path: inset(10% 0 70% 0); }
            100% { clip-path: inset(30% 0 20% 0); }
        }

        @keyframes glitch-anim-2 {
            0% { clip-path: inset(10% 0 60% 0); }
            20% { clip-path: inset(80% 0 5% 0); }
            40% { clip-path: inset(30% 0 20% 0); }
            60% { clip-path: inset(10% 0 80% 0); }
            80% { clip-path: inset(50% 0 30% 0); }
            100% { clip-path: inset(70% 0 10% 0); }
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .glitch { font-size: 2rem; }
            #ui-layer { padding: 1rem; gap: 1rem; }
            .interactive-controls { padding: 0.75rem; }
            
            /* Make controls smaller on mobile */
            label { font-size: 0.65rem; }
            #trail-val { font-size: 0.65rem; }
            button { font-size: 0.65rem; padding: 0.4rem 0.8rem; }
            .text-[10px] { font-size: 9px; }
        }
    </style>
</head>
<body>

    <canvas id="canvas1"></canvas>
    
    <div id="ui-layer">
        <div class="header">
            <h1 class="glitch" data-text="FLUX VORTEX">FLUX VORTEX</h1>
            <p class="text-sm opacity-80 tracking-widest">Click & Hold to Warp // Move to Disturb</p>
        </div>

        <div class="interactive-controls w-full max-w-md self-start">
            <div class="flex flex-col gap-4">
                
                <div class="flex justify-between items-center">
                    <label class="text-xs uppercase font-bold">Trippiness (Trails)</label>
                    <span id="trail-val" class="text-xs font-mono">50%</span>
                </div>
                <input type="range" id="trail-slider" min="1" max="99" value="15">

                <div class="flex justify-between items-center gap-2">
                    <button id="btn-mode" class="flex-1 bg-white text-black px-4 py-2 font-bold uppercase text-xs hover:bg-gray-200 transition">
                        Mode: Flow
                    </button>
                    <button id="btn-mirror" class="flex-1 border border-white px-4 py-2 font-bold uppercase text-xs hover:bg-white hover:text-black transition">
                        Kaleidoscope: Off
                    </button>
                </div>

                <div class="flex justify-between text-[10px] opacity-60 font-mono mt-2">
                    <span>FPS: <span id="fps">60</span></span>
                    <span>Particles: <span id="p-count">0</span></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const trailSlider = document.getElementById('trail-slider');
        const trailValDisplay = document.getElementById('trail-val');
        const btnMode = document.getElementById('btn-mode');
        const btnMirror = document.getElementById('btn-mirror');
        const fpsDisplay = document.getElementById('fps');
        const pCountDisplay = document.getElementById('p-count');

        // State
        let width, height;
        let particlesArray = [];
        let hue = 0;
        let frame = 0;
        let isWarping = false;
        
        // Configuration
        const config = {
            trail: 0.15, // Alpha value for clearing canvas (lower = longer trails)
            mode: 'flow', // flow, vortex, noise
            mirror: false,
            particleCount: 0, // Dynamic
            baseSpeed: 2,
            warpSpeed: 15,
            colorCycleSpeed: 1
        };

        // Mouse State
        const mouse = {
            x: undefined,
            y: undefined,
            radius: 200
        };

        // High-DPI Resize Handler
        function resize() {
            // 1. Handle Pixel Ratio for crisp rendering on mobile/retina
            const dpr = window.devicePixelRatio || 1;
            
            // Set internal resolution to match device capabilities
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            
            // Normalize Coordinate system so 1 unit = 1 css pixel
            ctx.scale(dpr, dpr);
            
            // Logical width/height for calculations
            width = window.innerWidth;
            height = window.innerHeight;

            // 2. Dynamic Particle Density
            // Calculate particles based on screen area (approx 1 per 2000px)
            const area = width * height;
            const density = Math.floor(area / 2000);
            // Clamp between 300 (min for fun) and 1500 (max for performance)
            config.particleCount = Math.min(1500, Math.max(300, density));

            initParticles();
        }

        window.addEventListener('resize', resize);

        // Interaction Handlers
        window.addEventListener('mousemove', function(e) {
            mouse.x = e.x;
            mouse.y = e.y;
        });

        window.addEventListener('mousedown', () => isWarping = true);
        window.addEventListener('mouseup', () => isWarping = false);
        
        // Touch support (Updated)
        window.addEventListener('touchstart', function(e) {
            // Prevent scrolling
            // e.preventDefault(); // managed by CSS touch-action
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            isWarping = true;
        }, {passive: false});

        window.addEventListener('touchmove', function(e) {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            isWarping = true; 
        }, {passive: false});

        window.addEventListener('touchend', () => {
            mouse.x = undefined;
            mouse.y = undefined;
            isWarping = false;
        });

        // UI Logic
        trailSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            const inverted = 100 - val;
            config.trail = inverted / 200; 
            trailValDisplay.innerText = val + '%';
        });

        btnMode.addEventListener('click', () => {
            const modes = ['flow', 'vortex', 'chaos'];
            const currentIdx = modes.indexOf(config.mode);
            config.mode = modes[(currentIdx + 1) % modes.length];
            btnMode.innerText = `Mode: ${config.mode}`;
            initParticles(); 
        });

        btnMirror.addEventListener('click', () => {
            config.mirror = !config.mirror;
            btnMirror.innerText = `Kaleidoscope: ${config.mirror ? 'On' : 'Off'}`;
            if(config.mirror) {
                btnMirror.classList.add('bg-white', 'text-black');
            } else {
                btnMirror.classList.remove('bg-white', 'text-black');
            }
        });

        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 5 + 1;
                this.speedX = Math.random() * 3 - 1.5;
                this.speedY = Math.random() * 3 - 1.5;
                this.angle = Math.random() * 360;
                this.spin = Math.random() < 0.5 ? 1 : -1;
                this.color = `hsl(${hue}, 100%, 50%)`;
                this.life = 0;
            }

            update() {
                this.life++;
                const speedMultiplier = isWarping ? config.warpSpeed : config.baseSpeed;

                // MODE: FLOW
                if (config.mode === 'flow') {
                    this.x += this.speedX * (isWarping ? 5 : 1);
                    this.y += this.speedY * (isWarping ? 5 : 1);

                    if (this.x > width || this.x < 0) this.speedX = -this.speedX;
                    if (this.y > height || this.y < 0) this.speedY = -this.speedY;

                    if (mouse.x != undefined) {
                        let dx = mouse.x - this.x;
                        let dy = mouse.y - this.y;
                        let dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < mouse.radius) {
                            const forceDirectionX = dx / dist;
                            const forceDirectionY = dy / dist;
                            const force = (mouse.radius - dist) / mouse.radius;
                            const directionX = forceDirectionX * force * this.size;
                            const directionY = forceDirectionY * force * this.size;
                            this.x -= directionX * 3;
                            this.y -= directionY * 3;
                        }
                    }
                } 
                
                // MODE: VORTEX
                else if (config.mode === 'vortex') {
                    const cx = width / 2;
                    const cy = height / 2;
                    
                    const dx = cx - this.x;
                    const dy = cy - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    const angle = Math.atan2(dy, dx);
                    const spiralForce = isWarping ? 15 : 2;
                    
                    this.x += Math.cos(angle + 1.5) * spiralForce;
                    this.y += Math.sin(angle + 1.5) * spiralForce;
                    
                    if (mouse.x != undefined) {
                         let mdx = mouse.x - this.x;
                         let mdy = mouse.y - this.y;
                         let mdist = Math.sqrt(mdx*mdx + mdy*mdy);
                         if (mdist < 150) {
                             this.x -= (mdx/mdist) * 10;
                             this.y -= (mdy/mdist) * 10;
                         }
                    }

                    if (dist < 10 || this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        if(Math.random() > 0.5) {
                            this.x = Math.random() > 0.5 ? 0 : width;
                        } else {
                            this.y = Math.random() > 0.5 ? 0 : height;
                        }
                    }
                }

                // MODE: CHAOS
                else if (config.mode === 'chaos') {
                    this.x += (Math.random() - 0.5) * (isWarping ? 50 : 10);
                    this.y += (Math.random() - 0.5) * (isWarping ? 50 : 10);
                    this.y += 2;

                    if(this.y > height) {
                        this.y = 0;
                        this.x = Math.random() * width;
                    }
                }

                const colorOffset = (this.x / width) * 60;
                this.color = `hsl(${hue + colorOffset}, 70%, 60%)`;
            }
        }

        function initParticles() {
            particlesArray = [];
            for (let i = 0; i < config.particleCount; i++) {
                particlesArray.push(new Particle());
            }
            pCountDisplay.innerText = config.particleCount;
        }

        function animate() {
            // Note: width and height here are logical CSS pixels, which works because we scaled the context
            ctx.fillStyle = `rgba(0, 0, 0, ${config.trail})`;
            ctx.fillRect(0, 0, width, height);

            hue += config.colorCycleSpeed + (isWarping ? 5 : 0);

            const cx = width / 2;
            const cy = height / 2;

            for (let i = 0; i < particlesArray.length; i++) {
                const p = particlesArray[i];
                p.update();
                
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();

                if (config.mirror) {
                    const rx = p.x - cx;
                    const ry = p.y - cy;
                    
                    // 90 deg
                    ctx.beginPath();
                    ctx.arc(cx - ry, cy + rx, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    // 180 deg
                    ctx.beginPath();
                    ctx.arc(cx - rx, cy - ry, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    // 270 deg
                    ctx.beginPath();
                    ctx.arc(cx + ry, cy - rx, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            if (frame % 3 === 0) {
                ctx.fillStyle = `rgba(0,0,0,0.1)`;
                ctx.fillRect(0, frame % height, width, 2);
            }

            frame++;
            requestAnimationFrame(animate);
        }

        // Start
        resize();
        animate();

        // FPS
        let lastTime = performance.now();
        let frames = 0;
        setInterval(() => {
            const now = performance.now();
            const fps = Math.round(frames * 1000 / (now - lastTime));
            fpsDisplay.innerText = fps;
            frames = 0;
            lastTime = now;
        }, 1000);

        function countFrames() {
            frames++;
            requestAnimationFrame(countFrames);
        }
        countFrames();

    </script>
</body>
</html>
